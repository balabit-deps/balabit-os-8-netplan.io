From: =?utf-8?q?Lukas_M=C3=A4rdian?= <slyon@ubuntu.com>
Date: Mon, 29 Nov 2021 15:24:43 +0100
Subject: dbus: wait for 'netplan try' to be ready (LP: #1949893) (#245)

netplan-dbus now waits for the spawned 'netplan try' child to touch the /run/netplan/netplan-try.ready stamp file before it returns the DBus call. If no stamp file is detected within up to 5 sec it hits a timeout and returns an error.

Additionally, this PR places ephemeral netplan configs in /run/netplan/config-XXXXXX, to avoid potential exploits of tmpfiles, like https://lwn.net/Articles/250468/

COMMITS:
* test:dbus: some cleanup
* test:utils: add touch() method to MockCmd
* cli:try: add touch/clear_ready_stamp methods
* dbus: wait for 'netplan try' to be ready
netplan-dbus now waits for the spawned 'netplan try' child to touch the
/tmp/netplan-try.ready stamp file before it returns the DBus call. If no
stamp file is detected within up to 5sec it hits a timeout and returns an
error.
* cli:apply: some more time for NM to have all interfaces created
* dbus:cli: move netplan-try.ready stamp file to /run/netplan
to avoid potential expolits of tmpfiles, like https://lwn.net/Articles/250468/
* dbus: move ephemeral netplan config states to /run/netplan
to avoid potential expolits of tmpfiles, like https://lwn.net/Articles/250468/
---
 doc/netplan-dbus.md                 |  4 +-
 netplan/cli/commands/apply.py       | 10 +++++
 netplan/cli/commands/try_command.py | 16 ++++++++
 src/dbus.c                          | 55 +++++++++++++++++++--------
 tests/dbus/test_dbus.py             | 74 ++++++++++++++++++++++++-------------
 tests/test_cli_units.py             | 24 ++++++++++++
 tests/test_utils.py                 |  4 ++
 7 files changed, 145 insertions(+), 42 deletions(-)

--- a/doc/netplan-dbus.md
+++ b/doc/netplan-dbus.md
@@ -24,8 +24,8 @@ netplan-dbus - daemon to access netplan'
 
 The ``/io/netplan/Netplan/config/<ID>`` objects provide a ``io.netplan.Netplan.Config`` interface, offering the following methods:
 
- * ``Get() -> s``: calls **netplan get --root-dir=/tmp/netplan-config-ID all** and returns the merged YAML config of the the given config object's state
- * ``Set(s:CONFIG_DELTA, s:ORIGIN_HINT) -> b``: calls **netplan set --root-dir=/tmp/netplan-config-ID --origin-hint=ORIGIN_HINT CONFIG_DELTA**
+ * ``Get() -> s``: calls **netplan get --root-dir=/run/netplan/config-ID all** and returns the merged YAML config of the the given config object's state
+ * ``Set(s:CONFIG_DELTA, s:ORIGIN_HINT) -> b``: calls **netplan set --root-dir=/run/netplan/config-ID --origin-hint=ORIGIN_HINT CONFIG_DELTA**
 
     CONFIG_DELTA can be something like: ``network.ethernets.eth0.dhcp4=true`` and ORIGIN_HINT can be something like: ``70-snapd`` (it will then write the config to ``70-snapd.yaml``). Once ``Set()`` is called on a config object, all other current and future config objects are being invalidated and cannot ``Set()`` or ``Try()/Apply()`` anymore, due to this pending dirty state. After the dirty config object is rejected via ``Cancel()``, the other config objects are valid again. If the dirty config object is accepted via ``Apply()``, newly created config objects will be valid, while the older states will stay invalid.
 
--- a/netplan/cli/commands/apply.py
+++ b/netplan/cli/commands/apply.py
@@ -32,6 +32,7 @@ from netplan.cli.sriov import apply_srio
 from netplan.cli.ovs import apply_ovs_cleanup
 
 import netifaces
+import time
 
 
 class NetplanApply(utils.NetplanCommand):
@@ -254,6 +255,15 @@ class NetplanApply(utils.NetplanCommand)
             for iface in utils.nm_interfaces(restart_nm_glob, devices):
                 utils.ip_addr_flush(iface)
             utils.systemctl_network_manager('start', sync=sync)
+            if sync:
+                # wait up to 2 sec for 'STATE=connected (site/local-only)' or
+                # 'STATE=connected' to appear in 'nmcli general' STATE
+                env = dict(os.environ, LC_ALL='C')
+                cmd = ['nmcli', 'general', 'status']
+                for _ in range(20):
+                    if b'\nconnected' in subprocess.check_output(cmd, env=env):
+                        break
+                    time.sleep(0.1)
 
     @staticmethod
     def is_composite_member(composites, phy):
--- a/netplan/cli/commands/try_command.py
+++ b/netplan/cli/commands/try_command.py
@@ -47,6 +47,8 @@ class NetplanTry(utils.NetplanCommand):
         self._config_manager = None
         self.t_settings = None
         self.t = None
+        self._rootdir = os.environ.get('DBUS_TEST_NETPLAN_ROOT', '/')
+        self._netplan_try_stamp = os.path.join(self._rootdir, 'run', 'netplan', 'netplan-try.ready')
 
     @property
     def config_manager(self):  # pragma: nocover (called by later commands)
@@ -54,6 +56,16 @@ class NetplanTry(utils.NetplanCommand):
             self._config_manager = ConfigManager()
         return self._config_manager
 
+    def clear_ready_stamp(self):
+        if os.path.isfile(self._netplan_try_stamp):
+            os.remove(self._netplan_try_stamp)
+            return True
+        return False
+
+    def touch_ready_stamp(self):
+        os.makedirs(self._rootdir + '/run/netplan', mode=0o700, exist_ok=True)
+        open(self._netplan_try_stamp, 'w').close()
+
     def run(self):  # pragma: nocover (requires user input)
         self.parser.add_argument('--config-file',
                                  help='Apply the config file in argument in addition to current configuration.')
@@ -86,6 +98,9 @@ class NetplanTry(utils.NetplanCommand):
 
             NetplanApply().command_apply(run_generate=True, sync=True, exit_on_error=False, state_dir=self.state)
 
+            # Touch stamp file, it is the signal (for netplan-dbus) that we're
+            # ready to accept any Accept/Reject input (like SIGUSR1 or SIGTERM)
+            self.touch_ready_stamp()
             self.t.get_confirmation_input(timeout=self.timeout)
         except netplan.terminal.InputRejected:
             print("\nReverting.")
@@ -100,6 +115,7 @@ class NetplanTry(utils.NetplanCommand):
             if self.t:
                 self.t.reset(self.t_settings)
             self.cleanup()
+            self.clear_ready_stamp()
 
     def backup(self):  # pragma: nocover (requires user input)
         backup_config_dir = False
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -170,7 +170,7 @@ _clear_tmp_state(const char *config_id,
 {
     g_autofree gchar *rootdir = NULL;
     /* Remove tmp YAML files */
-    rootdir = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), config_id);
+    rootdir = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, config_id);
     unlink_glob(rootdir, "/{etc,run,lib}/netplan/*.yaml");
 
     /* Remove tmp state directories */
@@ -204,7 +204,7 @@ _backup_global_state(sd_bus_error *ret_e
 {
     int r = 0;
     g_autofree gchar *path = NULL;
-    path = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), NETPLAN_GLOBAL_CONFIG);
+    path = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, NETPLAN_GLOBAL_CONFIG);
     /* Create {etc,run,lib} subdirs with owner r/w permissions */
     char *subdir = NULL;
     for (int i = 0; i < 3; i++) {
@@ -242,7 +242,7 @@ method_apply(sd_bus_message *m, void *us
     if (d->try_pid > 0)
         return _try_accept(TRUE, m, userdata, ret_error);
     if (d->config_id)
-        state = g_strdup_printf("--state=%s/netplan-config-%s", g_get_tmp_dir(), NETPLAN_GLOBAL_CONFIG);
+        state = g_strdup_printf("--state=%s/run/netplan/config-%s", NETPLAN_ROOT, NETPLAN_GLOBAL_CONFIG);
     gchar *argv[] = {SBINDIR "/" "netplan", "apply", state, NULL};
 
     // for tests only: allow changing what netplan to run
@@ -349,7 +349,7 @@ method_get(sd_bus_message *m, void *user
     gint exit_status = 0;
 
     if (d->config_id)
-        root_dir = g_strdup_printf("--root-dir=%s/netplan-config-%s", g_get_tmp_dir(), d->config_id);
+        root_dir = g_strdup_printf("--root-dir=%s/run/netplan/config-%s", NETPLAN_ROOT, d->config_id);
     gchar *argv[] = {SBINDIR "/" "netplan", "get", "all", root_dir, NULL};
 
     // for tests only: allow changing what netplan to run
@@ -392,7 +392,7 @@ method_set(sd_bus_message *m, void *user
     }
 
     if (d->config_id) {
-        root_dir = g_strdup_printf("--root-dir=%s/netplan-config-%s", g_get_tmp_dir(), d->config_id);
+        root_dir = g_strdup_printf("--root-dir=%s/run/netplan/config-%s", NETPLAN_ROOT, d->config_id);
         args[cur_arg] = root_dir;
         cur_arg++;
     }
@@ -423,7 +423,7 @@ netplan_try_cancelled_cb(sd_event_source
         /* Delete GLOBAL state */
         unlink_glob(NETPLAN_ROOT, "/{etc,run,lib}/netplan/*.yaml");
         /* Restore GLOBAL backup config state to main rootdir */
-        state_dir = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), NETPLAN_GLOBAL_CONFIG);
+        state_dir = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, NETPLAN_GLOBAL_CONFIG);
         _copy_yaml_state(state_dir, NETPLAN_ROOT, NULL);
 
         /* Un-invalidate all other current config objects */
@@ -448,6 +448,8 @@ method_try(sd_bus_message *m, void *user
     g_autoptr(GError) err = NULL;
     g_autofree gchar *timeout = NULL;
     g_autofree gchar *state = NULL;
+    g_autofree gchar *netplan_try_stamp = NULL;
+    struct stat buf;
     gint child_stdin = -1; /* child process needs an input to function correctly */
     guint seconds = 0;
     int r = -1;
@@ -458,13 +460,16 @@ method_try(sd_bus_message *m, void *user
     if (seconds > 0)
         timeout = g_strdup_printf("--timeout=%u", seconds);
     if (d->config_id)
-        state = g_strdup_printf("--state=%s/netplan-config-%s", g_get_tmp_dir(), NETPLAN_GLOBAL_CONFIG);
+        state = g_strdup_printf("--state=%s/run/netplan/config-%s", NETPLAN_ROOT, NETPLAN_GLOBAL_CONFIG);
     gchar *argv[] = {SBINDIR "/" "netplan", "try", timeout, state, NULL};
 
     // for tests only: allow changing what netplan to run
     if (getenv("DBUS_TEST_NETPLAN_CMD") != 0)
        argv[0] = getenv("DBUS_TEST_NETPLAN_CMD");
 
+    /* Delete any left-over netplan-try.ready stamp file, if it exists */
+    netplan_try_stamp = g_build_path("/", NETPLAN_ROOT, "run", "netplan", "netplan-try.ready", NULL);
+    unlink(netplan_try_stamp);
     /* Launch 'netplan try' child process, lock 'try_pid' to real PID */
     g_spawn_async_with_pipes("/", argv, NULL,
                              G_SPAWN_DO_NOT_REAP_CHILD|G_SPAWN_STDOUT_TO_DEV_NULL,
@@ -486,6 +491,21 @@ method_try(sd_bus_message *m, void *user
                                  "cannot watch 'netplan try' child: %s", strerror(-r));
         // LCOV_EXCL_STOP
 
+    /* wait for the /run/netplan/netplan-try.ready stamp file to appear */
+    guint poll_timeout = 500;
+    if (seconds > 0 && seconds < 5)
+        poll_timeout = seconds * 100;
+    /* Timeout after up to 5 sec of waiting for the stamp file */
+    for (int i = 0; i < poll_timeout; i++) {
+        if (stat(netplan_try_stamp, &buf) == 0)
+            break;
+        usleep(1000 * 10);
+    }
+    if (stat(netplan_try_stamp, &buf) != 0) {
+       g_debug("cannot find %s stamp file", netplan_try_stamp);
+       return sd_bus_reply_method_return(m, "b", false);
+    }
+
     return sd_bus_reply_method_return(m, "b", true);
 }
 
@@ -518,7 +538,7 @@ method_config_apply(sd_bus_message *m, v
         /* Delete GLOBAL state */
         unlink_glob(NETPLAN_ROOT, "/{etc,run,lib}/netplan/*.yaml");
         /* Copy current config state to GLOBAL */
-        state_dir = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), d->config_id);
+        state_dir = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, d->config_id);
         _copy_yaml_state(state_dir, NETPLAN_ROOT, ret_error);
         d->handler_id = g_strdup(d->config_id);
     }
@@ -593,7 +613,7 @@ method_config_try(sd_bus_message *m, voi
     unlink_glob(NETPLAN_ROOT, "/{etc,run,lib}/netplan/*.yaml");
 
     /* Copy current config *.yaml state to main rootdir (i.e. /etc/netplan/) */
-    state_dir = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), d->config_id);
+    state_dir = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, d->config_id);
     _copy_yaml_state(state_dir, NETPLAN_ROOT, ret_error);
 
     /* Exec try */
@@ -624,7 +644,7 @@ method_config_cancel(sd_bus_message *m,
         /* Delete GLOBAL state */
         unlink_glob(NETPLAN_ROOT, "/{etc,run,lib}/netplan/*.yaml");
         /* Restore GLOBAL backup config state to main rootdir */
-        state_dir = g_strdup_printf("%s/netplan-config-%s", g_get_tmp_dir(), NETPLAN_GLOBAL_CONFIG);
+        state_dir = g_strdup_printf("%s/run/netplan/config-%s", NETPLAN_ROOT, NETPLAN_GLOBAL_CONFIG);
         _copy_yaml_state(state_dir, NETPLAN_ROOT, ret_error);
 
         /* Clear GLOBAL backup and config state */
@@ -661,15 +681,20 @@ method_config(sd_bus_message *m, void *u
     NetplanData *d = userdata;
     sd_bus_slot *slot = NULL;
     g_autoptr(GError) err = NULL;
-    g_autofree gchar *path = NULL;
+    g_autofree gchar *tmpl = NULL;
+    g_autofree gchar *dir = NULL;
+    gchar *path = NULL;
     int r = 0;
 
-    /* Create temp. directory, according to "netplan-config-XXXXXX" template */
-    path = g_dir_make_tmp("netplan-config-XXXXXX", &err);
-    if (err != NULL)
+    /* Create state directory, according to "run/netplan/config-XXXXXX" template */
+    tmpl = g_build_path("/", NETPLAN_ROOT, "run", "netplan", "config-XXXXXX", NULL);
+    dir = g_path_get_dirname(tmpl);
+    r = g_mkdir_with_parents(dir, 0700);
+    path = g_mkdtemp(tmpl); // returns pointer to tmpl (with modified string)
+    if (r < 0 || !path)
         // LCOV_EXCL_START
         return sd_bus_error_setf(ret_error, SD_BUS_ERROR_FAILED,
-                                 "Failed to create temp dir: %s\n", err->message);
+                                 "Failed to create temp dir: %s\n", strerror(errno));
         // LCOV_EXCL_STOP
 
     /* Extract the last 6 randomly generated chars (i.e. "XXXXXX" from template) */
--- a/tests/dbus/test_dbus.py
+++ b/tests/dbus/test_dbus.py
@@ -40,6 +40,7 @@ class TestNetplanDBus(unittest.TestCase)
         os.makedirs(os.path.join(self.tmp, "etc", "netplan"), 0o700)
         os.makedirs(os.path.join(self.tmp, "lib", "netplan"), 0o700)
         os.makedirs(os.path.join(self.tmp, "run", "netplan"), 0o700)
+        self._netplan_try_stamp = os.path.join(self.tmp, 'run', 'netplan', 'netplan-try.ready')
         # Create main test YAML in /etc/netplan/
         test_file = os.path.join(self.tmp, 'etc', 'netplan', 'main_test.yaml')
         with open(test_file, 'w') as f:
@@ -106,7 +107,7 @@ class TestNetplanDBus(unittest.TestCase)
         self.assertIn(b'o "/io/netplan/Netplan/config/', out)
         cid = out.decode('utf-8').split('/')[-1].replace('"\n', '')
         # Verify that the state folders were created in /tmp
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
         self.assertTrue(os.path.isdir(tmpdir))
         self.assertTrue(os.path.isdir(os.path.join(tmpdir, 'etc', 'netplan')))
         self.assertTrue(os.path.isdir(os.path.join(tmpdir, 'run', 'netplan')))
@@ -283,7 +284,7 @@ class TestNetplanDBus(unittest.TestCase)
         self.assertTrue(os.path.isfile(os.path.join(self.tmp, 'run', 'netplan', 'run_test.yaml')))
 
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
         self.addClassCleanup(shutil.rmtree, tmpdir)
 
         # Verify the object path has been created, by calling .Config.Get() on that object
@@ -318,7 +319,7 @@ class TestNetplanDBus(unittest.TestCase)
 
     def test_netplan_dbus_config_set(self):
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
         self.addCleanup(shutil.rmtree, tmpdir)
 
         # Verify .Config.Set() on the config object
@@ -332,7 +333,6 @@ class TestNetplanDBus(unittest.TestCase)
         ]
         out = subprocess.check_output(BUSCTL_NETPLAN_CMD)
         self.assertEqual(b'b true\n', out)
-        print(self.mock_netplan_cmd.calls(), flush=True)
         self.assertEquals(self.mock_netplan_cmd.calls(), [[
             "netplan", "set", "ethernets.eth42.dhcp6=true",
             "--root-dir={}".format(tmpdir)
@@ -340,7 +340,7 @@ class TestNetplanDBus(unittest.TestCase)
 
     def test_netplan_dbus_config_get(self):
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
         self.addCleanup(shutil.rmtree, tmpdir)
 
         # Verify .Config.Get() on the config object
@@ -360,8 +360,8 @@ class TestNetplanDBus(unittest.TestCase)
 
     def test_netplan_dbus_config_cancel(self):
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
-        backup = '/tmp/netplan-config-BACKUP'
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
+        backup = self.tmp + '/run/netplan/config-BACKUP'
 
         # Verify .Config.Cancel() teardown of the config object and state dirs
         BUSCTL_NETPLAN_CMD = [
@@ -387,8 +387,8 @@ class TestNetplanDBus(unittest.TestCase)
 
     def test_netplan_dbus_config_apply(self):
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
-        backup = '/tmp/netplan-config-BACKUP'
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
+        backup = self.tmp + '/run/netplan/config-BACKUP'
         with open(os.path.join(tmpdir, 'etc', 'netplan', 'apply_test.yaml'), 'w') as f:
             f.write('TESTING-apply')
         with open(os.path.join(tmpdir, 'lib', 'netplan', 'apply_test.yaml'), 'w') as f:
@@ -406,7 +406,8 @@ class TestNetplanDBus(unittest.TestCase)
         ]
         out = subprocess.check_output(BUSCTL_NETPLAN_CMD)
         self.assertEqual(b'b true\n', out)
-        self.assertEquals(self.mock_netplan_cmd.calls(), [["netplan", "apply", "--state=/tmp/netplan-config-BACKUP"]])
+        self.assertEquals(self.mock_netplan_cmd.calls(),
+                          [["netplan", "apply", "--state=%s/run/netplan/config-BACKUP" % self.tmp]])
         time.sleep(1)  # Give some time for 'Apply' to clean up
         self.assertFalse(os.path.isdir(tmpdir))
 
@@ -424,11 +425,14 @@ class TestNetplanDBus(unittest.TestCase)
         self.assertFalse(os.path.isdir(tmpdir))
 
     def test_netplan_dbus_config_try_cancel(self):
+        # touch self._netplan_try_stamp to signal that 'netplan try' is ready
+        # to take (Accept/Reject) input signals, before the timeout
+        self.mock_netplan_cmd.touch(self._netplan_try_stamp)
         # self-terminate after 30 dsec = 3 sec, if not cancelled before
         self.mock_netplan_cmd.set_timeout(30)
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
-        backup = '/tmp/netplan-config-BACKUP'
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
+        backup = self.tmp + '/run/netplan/config-BACKUP'
         with open(os.path.join(tmpdir, 'etc', 'netplan', 'try_test.yaml'), 'w') as f:
             f.write('TESTING-try')
         with open(os.path.join(tmpdir, 'lib', 'netplan', 'try_test.yaml'), 'w') as f:
@@ -489,13 +493,14 @@ class TestNetplanDBus(unittest.TestCase)
 
         # Verify 'netplan try' has been called
         self.assertEquals(self.mock_netplan_cmd.calls(),
-                          [["netplan", "try", "--timeout=3", "--state=/tmp/netplan-config-BACKUP"]])
+                          [["netplan", "try", "--timeout=3", "--state=%s/run/netplan/config-BACKUP" % self.tmp]])
 
     def test_netplan_dbus_config_try_cb(self):
+        self.mock_netplan_cmd.touch(self._netplan_try_stamp)
         self.mock_netplan_cmd.set_timeout(1)  # actually self-terminate after 0.1 sec
         cid = self._new_config_object()
-        tmpdir = '/tmp/netplan-config-{}'.format(cid)
-        backup = '/tmp/netplan-config-BACKUP'
+        tmpdir = self.tmp + '/run/netplan/config-{}'.format(cid)
+        backup = self.tmp + '/run/netplan/config-BACKUP'
         with open(os.path.join(tmpdir, 'etc', 'netplan', 'try_test.yaml'), 'w') as f:
             f.write('TESTING-try')
         with open(os.path.join(tmpdir, 'lib', 'netplan', 'try_test.yaml'), 'w') as f:
@@ -512,7 +517,7 @@ class TestNetplanDBus(unittest.TestCase)
         ]
         out = subprocess.check_output(BUSCTL_NETPLAN_CMD)
         self.assertEqual(b'b true\n', out)
-        time.sleep(1.5)  # Give some time for the timeout to happen
+        time.sleep(1.5)  # Give some time for the callback to clean up
 
         # Verify the backup and config state dir are gone
         self.assertFalse(os.path.isdir(backup))
@@ -530,9 +535,10 @@ class TestNetplanDBus(unittest.TestCase)
 
         # Verify 'netplan try' has been called
         self.assertEquals(self.mock_netplan_cmd.calls(),
-                          [["netplan", "try", "--timeout=1", "--state=/tmp/netplan-config-BACKUP"]])
+                          [["netplan", "try", "--timeout=1", "--state=%s/run/netplan/config-BACKUP" % self.tmp]])
 
     def test_netplan_dbus_config_try_apply(self):
+        self.mock_netplan_cmd.touch(self._netplan_try_stamp)
         self.mock_netplan_cmd.set_timeout(30)  # 30 dsec = 3 sec
         cid = self._new_config_object()
         BUSCTL_NETPLAN_CMD = [
@@ -556,6 +562,7 @@ class TestNetplanDBus(unittest.TestCase)
         self.assertIn('Another \'netplan try\' process is already running', err)
 
     def test_netplan_dbus_config_try_config_try(self):
+        self.mock_netplan_cmd.touch(self._netplan_try_stamp)
         self.mock_netplan_cmd.set_timeout(50)  # 50 dsec = 5 sec
         cid = self._new_config_object()
         BUSCTL_NETPLAN_CMD = [
@@ -579,6 +586,22 @@ class TestNetplanDBus(unittest.TestCase)
         err = self._check_dbus_error(BUSCTL_NETPLAN_CMD2)
         self.assertIn('Another Try() is currently in progress: PID ', err)
 
+    def test_netplan_dbus_config_try_no_ready_signal(self):
+        # Do NOT touch the /tmp/netplan-try.rady stamp file to indicate that
+        # 'netplan try' is not ready to take any signals
+        self.mock_netplan_cmd.set_timeout(1)
+        self.assertFalse(os.path.isfile(self._netplan_try_stamp))
+        cid = self._new_config_object()
+        BUSCTL_NETPLAN_CMD = [
+            "busctl", "call", "--system",
+            "io.netplan.Netplan",
+            "/io/netplan/Netplan/config/{}".format(cid),
+            "io.netplan.Netplan.Config",
+            "Try", "u", "1",
+        ]
+        out = subprocess.check_output(BUSCTL_NETPLAN_CMD)
+        self.assertEqual(b'b false\n', out)
+
     def test_netplan_dbus_config_set_invalidate(self):
         self.mock_netplan_cmd.set_timeout(30)  # 30 dsec = 3 sec
         cid = self._new_config_object()
@@ -648,10 +671,10 @@ class TestNetplanDBus(unittest.TestCase)
         # Verify that Set()/Apply() was only called by one config object
         self.assertEquals(self.mock_netplan_cmd.calls(), [
             ["netplan", "set", "ethernets.eth0.dhcp4=true", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid)],
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid)],
             ["netplan", "set", "ethernets.eth0.dhcp4=yes", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid)],
-            ["netplan", "apply", "--state=/tmp/netplan-config-BACKUP"]
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid)],
+            ["netplan", "apply", "--state=%s/run/netplan/config-BACKUP" % self.tmp]
         ])
 
         # Now it works again
@@ -718,12 +741,13 @@ class TestNetplanDBus(unittest.TestCase)
         # Verify the call stack
         self.assertEquals(self.mock_netplan_cmd.calls(), [
             ["netplan", "set", "ethernets.eth0.dhcp4=true", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid)],
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid)],
             ["netplan", "set", "ethernets.eth0.dhcp4=false", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid2)]
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid2)]
         ])
 
     def test_netplan_dbus_config_set_uninvalidate_timeout(self):
+        self.mock_netplan_cmd.touch(self._netplan_try_stamp)
         self.mock_netplan_cmd.set_timeout(1)  # actually self-terminate process after 0.1 sec
         cid = self._new_config_object()
         cid2 = self._new_config_object()
@@ -767,8 +791,8 @@ class TestNetplanDBus(unittest.TestCase)
         # Verify the call stack
         self.assertEquals(self.mock_netplan_cmd.calls(), [
             ["netplan", "set", "ethernets.eth0.dhcp4=true", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid)],
-            ["netplan", "try", "--timeout=1", "--state=/tmp/netplan-config-BACKUP"],
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid)],
+            ["netplan", "try", "--timeout=1", "--state=%s/run/netplan/config-BACKUP" % self.tmp],
             ["netplan", "set", "ethernets.eth0.dhcp4=false", "--origin-hint=70-snapd",
-             "--root-dir=/tmp/netplan-config-{}".format(cid2)]
+             "--root-dir={}/run/netplan/config-{}".format(self.tmp, cid2)]
         ])
--- a/tests/test_cli_units.py
+++ b/tests/test_cli_units.py
@@ -17,16 +17,28 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+import os
+import shutil
 import unittest
 import subprocess
+import tempfile
 
 from unittest.mock import patch
 from netplan.cli.commands.apply import NetplanApply
+from netplan.cli.commands.try_command import NetplanTry
 
 
 class TestCLI(unittest.TestCase):
     '''Netplan CLI unittests'''
 
+    def setUp(self):
+        self.tmproot = tempfile.mkdtemp()
+        os.mkdir(os.path.join(self.tmproot, 'run'))
+        os.environ['DBUS_TEST_NETPLAN_ROOT'] = self.tmproot
+
+    def tearDown(self):
+        shutil.rmtree(self.tmproot)
+
     def test_is_composite_member(self):
         res = NetplanApply.is_composite_member([{'br0': {'interfaces': ['eth0']}}], 'eth0')
         self.assertTrue(res)
@@ -79,3 +91,15 @@ class TestCLI(unittest.TestCase):
             self.assertEquals(res, [])
             self.assertEqual(ctx.output, ['WARNING:root:Cannot clear virtual links: no network interfaces provided.'])
         mock.assert_not_called()
+
+    def test_netplan_try_ready_stamp(self):
+        stamp_file = os.path.join(self.tmproot, 'run', 'netplan', 'netplan-try.ready')
+        cmd = NetplanTry()
+        self.assertFalse(os.path.isfile(stamp_file))
+        # make sure it behaves correctly, if the file doesn't exist
+        self.assertFalse(cmd.clear_ready_stamp())
+        self.assertFalse(os.path.isfile(stamp_file))
+        cmd.touch_ready_stamp()
+        self.assertTrue(os.path.isfile(stamp_file))
+        self.assertTrue(cmd.clear_ready_stamp())
+        self.assertFalse(os.path.isfile(stamp_file))
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -68,6 +68,10 @@ printf '\\0' >> %(log)s
         with open(self.path, "a") as fp:
             fp.write("cat << EOF\n%s\nEOF" % output)
 
+    def touch(self, stamp_path):
+        with open(self.path, "a") as fp:
+            fp.write("touch %s\n" % stamp_path)
+
     def set_timeout(self, timeout_dsec=10):
         with open(self.path, "a") as fp:
             fp.write("""
