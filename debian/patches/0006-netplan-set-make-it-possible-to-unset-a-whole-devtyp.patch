From: Simon Chopin <simon.chopin@canonical.com>
Date: Mon, 4 Oct 2021 14:18:50 +0200
Subject: netplan: set: make it possible to unset a whole devtype subtree (LP:
 #1942930) (FR-1685) (#236)
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

BACKPORT (from upstream): moving names.c ENUM_FUNCTION logic into util.c

Previously, trying to unset a whole devtype subtree, such as netplan set network.ethernets=null would fail. This PR fixes it by detecting this special case and manually deleting each netdef assigned to the subtype.

This approach is far from being performant, but it has the merit of working without needing too much new code.

COMMITS:
* tests: cli_get_set: use assertRaises to check for exceptions
This allows the test machinery to do some better error reporting when an
exception is raised, as it understands that the issue is an uncaught
exception, not a failed comparison.

* lib: names: add a function to parse a string into a devtype
As I'm expecting this kind of function to be useful for the parser, the
implementation is directly in the form of a macro modelled after its
counterpart.

* lib,netplan: tell Python about all the netdefs for a given devtype
This is implemented via iterators to limit the knowledge Python has of
the underlying memory model. The new symbols are prefixed with '_' to
denote that they are not to be used by public consumers.

We also expose process_yaml_hierarchy which was already part of the ABI,
as it seems needed for the Python helper implementation.

Contrary to the usual FFI calls, this one explicitly checks the
existence of the symbols and raises an exception if the symbols are not
found, as it is not totally unlikely that netplan.io and libnetplan0 be
upgraded out of sync.

V2: rename the C internal iterator struct, which hadn't evolved along
with the successive iterations on the code

fixup itar

* netplan: set: allow the removal of an entire devtype subtree
See LP: #1942930

Note that performance for this are horrendous, as we parse the whole
tree once for *each* removed netdef!

V2:
* Lukas as co-author, as he wrote the test!
* Clean up commented-out code in the tests

Co-authored-by: Lukas MÃ¤rdian <lukas.maerdian@canonical.com>
---
 netplan/cli/commands/set.py |  9 +++++++-
 netplan/cli/utils.py        | 46 +++++++++++++++++++++++++++++++++++++
 src/util.c                  | 55 ++++++++++++++++++++++++++++++++++++++++++++
 tests/test_cli_get_set.py   | 56 ++++++++++++++++++++++++++++-----------------
 tests/test_utils.py         | 33 ++++++++++++++++++++++++++
 5 files changed, 177 insertions(+), 22 deletions(-)

diff --git a/netplan/cli/commands/set.py b/netplan/cli/commands/set.py
index 3bf7dc6..2d75cac 100644
--- a/netplan/cli/commands/set.py
+++ b/netplan/cli/commands/set.py
@@ -59,7 +59,14 @@ class NetplanSet(utils.NetplanCommand):
         for devtype in network:
             if devtype in GLOBAL_KEYS:
                 continue  # special handling of global keys down below
-            for netdef in network.get(devtype, []):
+            devtype_content = network.get(devtype, [])
+            # Special case: removal of a whole devtype.
+            # We replace the devtype null node with a dict of all defined netdefs
+            # set to None.
+            if devtype_content is None:
+                devtype_content = {dev: None for dev in utils.netplan_get_ids_for_devtype(devtype, self.root_dir)}
+                network[devtype] = devtype_content
+            for netdef in devtype_content:
                 hint = FALLBACK_HINT
                 filename = utils.netplan_get_filename_by_id(netdef, self.root_dir)
                 if filename:
diff --git a/netplan/cli/utils.py b/netplan/cli/utils.py
index b0c87c9..656d60f 100644
--- a/netplan/cli/utils.py
+++ b/netplan/cli/utils.py
@@ -32,6 +32,10 @@ NM_SERVICE_NAME = 'NetworkManager.service'
 NM_SNAP_SERVICE_NAME = 'snap.network-manager.networkmanager.service'
 
 
+class LibNetplanException(Exception):
+    pass
+
+
 class _GError(ctypes.Structure):
     _fields_ = [("domain", ctypes.c_uint32), ("code", ctypes.c_int), ("message", ctypes.c_char_p)]
 
@@ -39,6 +43,8 @@ class _GError(ctypes.Structure):
 lib = ctypes.CDLL(ctypes.util.find_library('netplan'))
 lib.netplan_parse_yaml.argtypes = [ctypes.c_char_p, ctypes.POINTER(ctypes.POINTER(_GError))]
 lib.netplan_get_filename_by_id.restype = ctypes.c_char_p
+lib.process_yaml_hierarchy.argtypes = [ctypes.c_char_p]
+lib.process_yaml_hierarchy.restype = ctypes.c_int
 
 
 def netplan_parse(path):
@@ -59,6 +65,46 @@ def netplan_get_filename_by_id(netdef_id, rootdir):
     return res.decode('utf-8') if res else None
 
 
+class _NetdefIdIterator:
+    def __init__(self, devtype):
+        self.iterator = lib._netplan_iter_defs_per_devtype_init(devtype.encode('utf-8'))
+
+    def __del__(self):
+        lib._netplan_iter_defs_per_devtype_free(self.iterator)
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        next_value = lib._netplan_iter_defs_per_devtype_next(self.iterator)
+        if next_value is None:
+            raise StopIteration
+        return next_value
+
+
+def netplan_get_ids_for_devtype(devtype, rootdir):
+    if not hasattr(lib, '_netplan_iter_defs_per_devtype_init'):  # pragma: nocover (hard to unit-test against the WRONG lib)
+        raise LibNetplanException('''
+            The current version of libnetplan does not allow iterating by devtype.
+            Please ensure that both the netplan CLI package and its library are up to date.
+        ''')
+    lib._netplan_iter_defs_per_devtype_init.argtypes = [ctypes.c_char_p]
+    lib._netplan_iter_defs_per_devtype_init.restype = ctypes.c_void_p
+
+    lib._netplan_iter_defs_per_devtype_next.argtypes = [ctypes.c_void_p]
+    lib._netplan_iter_defs_per_devtype_next.restype = ctypes.c_void_p
+
+    lib._netplan_iter_defs_per_devtype_free.argtypes = [ctypes.c_void_p]
+    lib._netplan_iter_defs_per_devtype_free.restype = None
+
+    lib._netplan_netdef_id.argtypes = [ctypes.c_void_p]
+    lib._netplan_netdef_id.restype = ctypes.c_char_p
+
+    lib.process_yaml_hierarchy(rootdir.encode('utf-8'))
+    nds = list(_NetdefIdIterator(devtype))
+    return [lib._netplan_netdef_id(nd).decode('utf-8') for nd in nds]
+
+
 def get_generator_path():
     return os.environ.get('NETPLAN_GENERATE_PATH', '/lib/netplan/generate')
 
diff --git a/src/util.c b/src/util.c
index a4c0dba..4c8d716 100644
--- a/src/util.c
+++ b/src/util.c
@@ -327,3 +327,58 @@ get_global_network(int ip_family)
     else
         return "::/0";
 }
+
+#define ENUM_FUNCTION(_radical, _type) _type netplan_ ## _radical ## _from_name(const char* val) \
+{ \
+    for (int i = 0; i < sizeof(netplan_ ## _radical ## _to_str); ++i) { \
+        if (g_strcmp0(val, netplan_ ## _radical ## _to_str[i]) == 0) \
+            return i; \
+    } \
+    return -1; \
+}
+
+ENUM_FUNCTION(def_type, NetplanDefType);
+
+struct netdef_pertype_iterator {
+    NetplanDefType type;
+    GHashTableIter iter;
+};
+
+struct netdef_pertype_iterator*
+_netplan_iter_defs_per_devtype_init(const char *devtype)
+{
+    NetplanDefType type = netplan_def_type_from_name(devtype);
+    struct netdef_pertype_iterator *iter = g_malloc0(sizeof(*iter));
+    iter->type = type;
+    if (netdefs)
+        g_hash_table_iter_init(&iter->iter, netdefs);
+    return iter;
+}
+
+NetplanNetDefinition*
+_netplan_iter_defs_per_devtype_next(struct netdef_pertype_iterator* it)
+{
+    gpointer key, value;
+
+    if (!netdefs)
+        return NULL;
+
+    while (g_hash_table_iter_next(&it->iter, &key, &value)) {
+        NetplanNetDefinition* netdef = value;
+        if (netdef->type == it->type)
+            return netdef;
+    }
+    return NULL;
+}
+
+void
+_netplan_iter_defs_per_devtype_free(struct netdef_pertype_iterator* it)
+{
+    g_free(it);
+}
+
+const char*
+_netplan_netdef_id(NetplanNetDefinition* nd)
+{
+    return nd->id;
+}
diff --git a/tests/test_cli_get_set.py b/tests/test_cli_get_set.py
index 7a1799b..b5206e7 100644
--- a/tests/test_cli_get_set.py
+++ b/tests/test_cli_get_set.py
@@ -31,13 +31,11 @@ from netplan.cli.core import Netplan
 def _call_cli(args):
     old_sys_argv = sys.argv
     sys.argv = [old_sys_argv[0]] + args
+    f = io.StringIO()
     try:
-        f = io.StringIO()
         with redirect_stdout(f):
             Netplan().main()
             return f.getvalue()
-    except Exception as e:
-        return e
     finally:
         sys.argv = old_sys_argv
 
@@ -110,20 +108,20 @@ class TestSet(unittest.TestCase):
             self.assertEquals('network:\n  ethernets:\n    eth0:\n      dhcp4: true\n', f.read())
 
     def test_set_empty_origin_hint(self):
-        err = self._set(['ethernets.eth0.dhcp4=true', '--origin-hint='])
-        self.assertIsInstance(err, Exception)
-        self.assertIn('Invalid/empty origin-hint', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set(['ethernets.eth0.dhcp4=true', '--origin-hint='])
+        self.assertTrue('Invalid/empty origin-hint' in str(context.exception))
 
     def test_set_invalid(self):
-        err = self._set(['xxx.yyy=abc'])
-        self.assertIsInstance(err, Exception)
-        self.assertIn('unknown key \'xxx\'\n  xxx:\n', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set(['xxx.yyy=abc'])
+        self.assertIn('unknown key \'xxx\'\n  xxx:\n', str(context.exception))
         self.assertFalse(os.path.isfile(self.path))
 
     def test_set_invalid_validation(self):
-        err = self._set(['ethernets.eth0.set-name=myif0'])
-        self.assertIsInstance(err, Exception)
-        self.assertIn('eth0: \'set-name:\' requires \'match:\' properties', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set(['ethernets.eth0.set-name=myif0'])
+        self.assertIn('eth0: \'set-name:\' requires \'match:\' properties', str(context.exception))
         self.assertFalse(os.path.isfile(self.path))
 
     def test_set_invalid_validation2(self):
@@ -134,9 +132,9 @@ class TestSet(unittest.TestCase):
       mode: sit
       local: 1.2.3.4
       remote: 5.6.7.8''')
-        err = self._set(['tunnels.tun0.keys.input=12345'])
-        self.assertIsInstance(err, Exception)
-        self.assertIn('tun0: \'input-key\' is not required for this tunnel type', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set(['tunnels.tun0.keys.input=12345'])
+        self.assertIn('tun0: \'input-key\' is not required for this tunnel type', str(context.exception))
 
     def test_set_append(self):
         with open(self.path, 'w') as f:
@@ -195,6 +193,20 @@ class TestSet(unittest.TestCase):
             self.assertNotIn('addresses:', out)
             self.assertNotIn('eth0:', out)
 
+    def test_set_delete_subtree(self):
+        with open(self.path, 'w') as f:
+            f.write('''network:\n  version: 2\n  renderer: NetworkManager
+  ethernets:
+    eth0: {addresses: [1.2.3.4/24]}''')
+        self._set(['network.ethernets=null'])
+        self.assertTrue(os.path.isfile(self.path))
+        with open(self.path, 'r') as f:
+            out = f.read()
+        self.assertIn('network:\n', out)
+        self.assertIn(' version: 2\n', out)
+        self.assertIn(' renderer: NetworkManager\n', out)
+        self.assertNotIn('ethernets:', out)
+
     def test_set_delete_file(self):
         with open(self.path, 'w') as f:
             f.write('''network:
@@ -220,9 +232,9 @@ class TestSet(unittest.TestCase):
             f.write('''network:\n  version: 2\n  renderer: NetworkManager
   ethernets:
     eth0: {addresses: [1.2.3.4]}''')
-        err = self._set(['ethernets.eth0.addresses'])
-        self.assertIsInstance(err, Exception)
-        self.assertEquals('Invalid value specified', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set(['ethernets.eth0.addresses'])
+        self.assertEquals('Invalid value specified', str(context.exception))
 
     def test_set_escaped_dot(self):
         self._set([r'ethernets.eth0\.123.dhcp4=false'])
@@ -231,9 +243,11 @@ class TestSet(unittest.TestCase):
             self.assertIn('network:\n  ethernets:\n    eth0.123:\n      dhcp4: false', f.read())
 
     def test_set_invalid_input(self):
-        err = self._set([r'ethernets.eth0={dhcp4:false}'])
-        self.assertIsInstance(err, Exception)
-        self.assertEquals('Invalid input: {\'network\': {\'ethernets\': {\'eth0\': {\'dhcp4:false\': None}}}}', str(err))
+        with self.assertRaises(Exception) as context:
+            self._set([r'ethernets.eth0={dhcp4:false}'])
+        self.assertEquals(
+                'Invalid input: {\'network\': {\'ethernets\': {\'eth0\': {\'dhcp4:false\': None}}}}',
+                str(context.exception))
 
     def test_set_override_existing_file(self):
         override = os.path.join(self.workdir.name, 'etc', 'netplan', 'some-file.yaml')
diff --git a/tests/test_utils.py b/tests/test_utils.py
index 7954ec7..5c97ca2 100644
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -196,3 +196,36 @@ class TestUtils(unittest.TestCase):
       remote: 0.0.0.0
       key: 0.0.0.0''')
         self.assertIsNone(utils.netplan_get_filename_by_id('some-id', self.workdir.name))
+
+    def test_netplan_get_ids_for_devtype(self):
+        path = os.path.join(self.workdir.name, 'etc/netplan/a.yaml')
+        with open(path, 'w') as f:
+            f.write('''network:
+  ethernets:
+    id_b:
+      dhcp4: true
+    id_a:
+      dhcp4: true
+  vlans:
+    en-intra:
+      id: 3
+      link: id_b
+      dhcp4: true''')
+        self.assertSetEqual(
+                set(utils.netplan_get_ids_for_devtype("ethernets", self.workdir.name)),
+                set(["id_a", "id_b"]))
+
+    def test_netplan_get_ids_for_devtype_no_dev(self):
+        path = os.path.join(self.workdir.name, 'etc/netplan/a.yaml')
+        with open(path, 'w') as f:
+            f.write('''network:
+  ethernets:
+    id_b:
+      dhcp4: true''')
+        self.assertSetEqual(
+                set(utils.netplan_get_ids_for_devtype("tunnels", self.workdir.name)),
+                set([]))
+
+    def test_NetdefIdIterator_with_clear_netplan(self):
+        utils.lib.netplan_clear_netdefs()
+        self.assertSequenceEqual(list(utils._NetdefIdIterator("ethernets")), [])
