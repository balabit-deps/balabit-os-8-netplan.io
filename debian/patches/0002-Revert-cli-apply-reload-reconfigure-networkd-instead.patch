From: =?utf-8?q?Lukas_M=C3=A4rdian?= <slyon@ubuntu.com>
Date: Thu, 5 Aug 2021 15:54:00 +0200
Subject: Revert: cli:apply: reload/reconfigure networkd instead of restart
 (#200)

---
 netplan/cli/commands/apply.py | 18 +++-----
 netplan/cli/utils.py          | 49 ++++++++++------------
 tests/test_utils.py           | 97 -------------------------------------------
 3 files changed, 27 insertions(+), 137 deletions(-)

diff --git a/netplan/cli/commands/apply.py b/netplan/cli/commands/apply.py
index b1d4b9c..c3f5caa 100644
--- a/netplan/cli/commands/apply.py
+++ b/netplan/cli/commands/apply.py
@@ -25,15 +25,13 @@ import sys
 import glob
 import subprocess
 import shutil
-import netifaces
 
 import netplan.cli.utils as utils
 from netplan.configmanager import ConfigManager, ConfigurationError
 from netplan.cli.sriov import apply_sriov_config
 from netplan.cli.ovs import apply_ovs_cleanup
 
-
-OVS_CLEANUP_SERVICE = 'netplan-ovs-cleanup.service'
+import netifaces
 
 
 class NetplanApply(utils.NetplanCommand):
@@ -152,7 +150,7 @@ class NetplanApply(utils.NetplanCommand):
 
         # stop backends
         if restart_networkd:
-            logging.debug('netplan generated networkd configuration changed, reloading networkd')
+            logging.debug('netplan generated networkd configuration changed, restarting networkd')
             # Running 'systemctl daemon-reload' will re-run the netplan systemd generator,
             # so let's make sure we only run it iff we're willing to run 'netplan generate'
             if run_generate:
@@ -164,7 +162,7 @@ class NetplanApply(utils.NetplanCommand):
             # upgraded system, we need to make sure to stop those.
             if utils.systemctl_is_active('netplan-wpa@*.service'):
                 wpa_services.insert(0, 'netplan-wpa@*.service')
-            utils.systemctl('stop', wpa_services, sync=sync)
+            utils.systemctl_networkd('stop', sync=sync, extra_services=wpa_services)
         else:
             logging.debug('no netplan generated networkd configuration exists')
 
@@ -233,16 +231,10 @@ class NetplanApply(utils.NetplanCommand):
         # (re)start backends
         if restart_networkd:
             netplan_wpa = [os.path.basename(f) for f in glob.glob('/run/systemd/system/*.wants/netplan-wpa-*.service')]
-            # exclude the special 'netplan-ovs-cleanup.service' unit
-            netplan_ovs = [os.path.basename(f) for f in glob.glob('/run/systemd/system/*.wants/netplan-ovs-*.service')
-                           if not f.endswith('/' + OVS_CLEANUP_SERVICE)]
+            netplan_ovs = [os.path.basename(f) for f in glob.glob('/run/systemd/system/*.wants/netplan-ovs-*.service')]
             # Run 'systemctl start' command synchronously, to avoid race conditions
             # with 'oneshot' systemd service units, e.g. netplan-ovs-*.service.
-            utils.networkctl_reconfigure(utils.networkd_interfaces())
-            # 1st: execute OVS cleanup, to avoid races while applying OVS config
-            utils.systemctl('start', [OVS_CLEANUP_SERVICE], sync=True)
-            # 2nd: start all other services
-            utils.systemctl('start', netplan_wpa + netplan_ovs, sync=True)
+            utils.systemctl_networkd('start', sync=True, extra_services=netplan_wpa + netplan_ovs)
         if restart_nm:
             # Flush all IP addresses of NM managed interfaces, to avoid NM creating
             # new, non netplan-* connection profiles, using the existing IPs.
diff --git a/netplan/cli/utils.py b/netplan/cli/utils.py
index 0a04692..b0c87c9 100644
--- a/netplan/cli/utils.py
+++ b/netplan/cli/utils.py
@@ -63,7 +63,7 @@ def get_generator_path():
     return os.environ.get('NETPLAN_GENERATE_PATH', '/lib/netplan/generate')
 
 
-def is_nm_snap_enabled():
+def is_nm_snap_enabled():  # pragma: nocover (covered in autopkgtest)
     return subprocess.call(['systemctl', '--quiet', 'is-enabled', NM_SNAP_SERVICE_NAME], stderr=subprocess.DEVNULL) == 0
 
 
@@ -100,55 +100,50 @@ def nm_interfaces(paths, devices):
     return interfaces
 
 
-def systemctl_network_manager(action, sync=False):
+def systemctl_network_manager(action, sync=False):  # pragma: nocover (covered in autopkgtest)
+    service_name = NM_SERVICE_NAME
+
+    command = ['systemctl', action]
+    if not sync:
+        command.append('--no-block')
+
     # If the network-manager snap is installed use its service
     # name rather than the one of the deb packaged NetworkManager
     if is_nm_snap_enabled():
-        return systemctl(action, [NM_SNAP_SERVICE_NAME], sync)
-    return systemctl(action, [NM_SERVICE_NAME], sync)  # pragma: nocover (covered in autopkgtest)
-
+        service_name = NM_SNAP_SERVICE_NAME
 
-def systemctl(action, services, sync=False):
-    if len(services) >= 1:
-        command = ['systemctl', action]
+    command.append(service_name)
 
-        if not sync:
-            command.append('--no-block')
+    subprocess.check_call(command)
 
-        command.extend(services)
 
-        subprocess.check_call(command)
+def systemctl_networkd(action, sync=False, extra_services=[]):  # pragma: nocover (covered in autopkgtest)
+    command = ['systemctl', action]
 
+    if not sync:
+        command.append('--no-block')
 
-def networkd_interfaces():
-    interfaces = set()
-    out = subprocess.check_output(['networkctl', '--no-pager', '--no-legend'], universal_newlines=True)
-    for line in out.splitlines():
-        s = line.strip().split(' ')
-        if s[0].isnumeric() and s[-1] not in ['unmanaged', 'linger']:
-            interfaces.add(s[1])
-    return interfaces
+    command.append('systemd-networkd.service')
 
+    for service in extra_services:
+        command.append(service)
 
-def networkctl_reconfigure(interfaces):
-    subprocess.check_call(['networkctl', 'reload'])
-    if len(interfaces) >= 1:
-        subprocess.check_call(['networkctl', 'reconfigure'] + list(interfaces))
+    subprocess.check_call(command)
 
 
-def systemctl_is_active(unit_pattern):
+def systemctl_is_active(unit_pattern):  # pragma: nocover (covered in autopkgtest)
     '''Return True if at least one matching unit is running'''
     if subprocess.call(['systemctl', '--quiet', 'is-active', unit_pattern]) == 0:
         return True
     return False
 
 
-def systemctl_daemon_reload():
+def systemctl_daemon_reload():  # pragma: nocover (covered in autopkgtest)
     '''Reload systemd unit files from disk and re-calculate its dependencies'''
     subprocess.check_call(['systemctl', 'daemon-reload'])
 
 
-def ip_addr_flush(iface):
+def ip_addr_flush(iface):  # pragma: nocover (covered in autopkgtest)
     '''Flush all IP addresses of a given interface via iproute2'''
     subprocess.check_call(['ip', 'addr', 'flush', iface], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
 
diff --git a/tests/test_utils.py b/tests/test_utils.py
index 7b8fd6f..7954ec7 100644
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -196,100 +196,3 @@ class TestUtils(unittest.TestCase):
       remote: 0.0.0.0
       key: 0.0.0.0''')
         self.assertIsNone(utils.netplan_get_filename_by_id('some-id', self.workdir.name))
-
-    def test_systemctl(self):
-        self.mock_systemctl = MockCmd('systemctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_systemctl.path) + os.pathsep + path_env
-        utils.systemctl('start', ['service1', 'service2'])
-        self.assertEquals(self.mock_systemctl.calls(), [['systemctl', 'start', '--no-block', 'service1', 'service2']])
-
-    def test_networkd_interfaces(self):
-        self.mock_networkctl = MockCmd('networkctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_networkctl.path) + os.pathsep + path_env
-        self.mock_networkctl.set_output('''
-  1 lo              loopback carrier    unmanaged
-  2 ens3            ether    routable   configured
-  3 wlan0           wlan     routable   configuring
-174 wwan0           wwan     off        linger''')
-        res = utils.networkd_interfaces()
-        self.assertEquals(self.mock_networkctl.calls(), [['networkctl', '--no-pager', '--no-legend']])
-        self.assertIn('wlan0', res)
-        self.assertIn('ens3', res)
-
-    def test_networkctl_reconfigure(self):
-        self.mock_networkctl = MockCmd('networkctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_networkctl.path) + os.pathsep + path_env
-        utils.networkctl_reconfigure(['eth0', 'eth1'])
-        self.assertEquals(self.mock_networkctl.calls(), [
-            ['networkctl', 'reload'],
-            ['networkctl', 'reconfigure', 'eth0', 'eth1']
-        ])
-
-    def test_is_nm_snap_enabled(self):
-        self.mock_cmd = MockCmd('systemctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        self.assertTrue(utils.is_nm_snap_enabled())
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', '--quiet', 'is-enabled', 'snap.network-manager.networkmanager.service']
-        ])
-
-    def test_is_nm_snap_enabled_false(self):
-        self.mock_cmd = MockCmd('systemctl')
-        self.mock_cmd.set_returncode(1)
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        self.assertFalse(utils.is_nm_snap_enabled())
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', '--quiet', 'is-enabled', 'snap.network-manager.networkmanager.service']
-        ])
-
-    def test_systemctl_network_manager(self):
-        self.mock_cmd = MockCmd('systemctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        utils.systemctl_network_manager('start')
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', '--quiet', 'is-enabled', 'snap.network-manager.networkmanager.service'],
-            ['systemctl', 'start', '--no-block', 'snap.network-manager.networkmanager.service']
-        ])
-
-    def test_systemctl_is_active(self):
-        self.mock_cmd = MockCmd('systemctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        self.assertTrue(utils.systemctl_is_active('some.service'))
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', '--quiet', 'is-active', 'some.service']
-        ])
-
-    def test_systemctl_is_active_false(self):
-        self.mock_cmd = MockCmd('systemctl')
-        self.mock_cmd.set_returncode(1)
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        self.assertFalse(utils.systemctl_is_active('some.service'))
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', '--quiet', 'is-active', 'some.service']
-        ])
-
-    def test_systemctl_daemon_reload(self):
-        self.mock_cmd = MockCmd('systemctl')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        utils.systemctl_daemon_reload()
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['systemctl', 'daemon-reload']
-        ])
-
-    def test_ip_addr_flush(self):
-        self.mock_cmd = MockCmd('ip')
-        path_env = os.environ['PATH']
-        os.environ['PATH'] = os.path.dirname(self.mock_cmd.path) + os.pathsep + path_env
-        utils.ip_addr_flush('eth42')
-        self.assertEquals(self.mock_cmd.calls(), [
-            ['ip', 'addr', 'flush', 'eth42']
-        ])
